import skimage as ski
import numpy as np 
import scipy as sc
import matplotlib.pyplot as plt 

""" 
Support file for the Harris Corner detection algorithm ! 
"""

def load_image(path) :
  """
  function to read an image, convert it to grayscale, and display it.
  @ path : path to the image being read.
  """ 
  image  = ski.color.rgb2gray(ski.io.imread(path))
  plt.imshow(image,'gray')
  plt.show()
  return image


def CornerDetection(image):
  """
  function to take an image, calculate its deriviatives and find the response matrix for the Harris corner detector.
  @ image : image variable where we should find corners.
  """
  Sx = np.array([[0,0,0],[1,0,-1],[0,0,0]])
  Sy = np.array([[0,1,0],[0,0,0],[0,-1,0]])
  # We use convolutions to approximate Ix and Iy.
  Ix = sc.signal.convolve2d(image,Sx)
  Iy = sc.signal.convolve2d(image,Sy)
  # Calculate squares of the deriviatives.
  Ix2,Iy2,Ixy = Ix**2,Iy**2,Ix*Iy 
  # Calculate the sum of the 3x3 groupings of pixels.
  average= np.ones((3,3))
  Ixaverage = sc.signal.convolve2d(Ix2,average)
  Iyaverage = sc.signal.convolve2d(Iy2,average)
  Ixyaverage = sc.signal.convolve2d(Ixy,average)
  # And now we calculate the matrix C 
  R = np.float64(Ixaverage * Iyaverage - Ixyaverage**2 - 0.04 * (Ixaverage+Iyaverage)**2)
  a,b = R.shape
  R = R[2:a-2,2:b-2] 
  return R 


def CornerVisualisation(R,image,threshold):
  """
  function to visualise corners generated by the Harris Corner Detection algorithm.
  @ R     : response image matrix.
  @ image : original image.
  @ threshold : threshold used to separate what's a corner and what's not.
  """
  positions = np.argwhere(R>threshold)
  _,ax = plt.subplots() 
  ax.imshow(image,'gray')
  for y,x in positions : 
    plt.plot(x,y,marker='o',markersize=3,color='red')
  plt.show()


def LocalMaximum(R) :
  """
  function to find the local maxima of a 3x3 matrix, we can compare the matrix by its shifted version in all directions
  @ R : Harris corner detection response matrix.
  """ 
  R     = np.array(R)
  up    = np.roll(R,-1,axis=0)
  down  = np.roll(R,1,axis=0)
  right = np.roll(R,1,axis=1)
  left  = np.roll(R,-1,axis=1)
  upleft = np.roll(up,-1,axis=1)
  upright = np.roll(up,1,axis=1)
  downright = np.roll(down,1,axis=1)
  downleft = np.roll(down,-1,axis=1)
  # The comparison
  is_max = ((R> up) & (R> down) & (R> right) & (R>left) & (R>upright) & (R>upleft) & (R>downright) & (R>downleft))
  localmaxonly = np.where(is_max,R,0)
  return localmaxonly